# Models

Now we can get started on our models. The data models we need to get started with are simple: there’s `Post` which contains the blog post, and `Tag`, which contains the tag text. They are related to each other with a `ManyToManyField`. We won’t spend too much time going through them as you should be familiar with Django models.

Import `settings` in addition to `models` from their respective locations.

```python
from django.db import models
from django.conf import settings
```

Here’s the `Tag` class.

```python
class Tag(models.Model):
    value = models.TextField(max_length=100)

    def __str__(self):
        return self.value
```

It’s simple and just contains a single field for `value`.

The `Post` model is a little more complex but hopefully the fields aren’t too unfamiliar.

```python
class Post(models.Model):
    author = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.PROTECT)
    created_at = models.DateTimeField(auto_now_add=True)
    modified_at = models.DateTimeField(auto_now=True)
    published_at = models.DateTimeField(blank=True, null=True)
    title = models.TextField(max_length=100)
    slug = models.SlugField()
    summary = models.TextField(max_length=500)
    content = models.TextField()
    tags = models.ManyToManyField(Tag, related_name="posts")

    def __str__(self):
        return self.title
```

Some of the things of note to point out are:

### Author Foreign Key

The `author` is a `ForeignKey` to `settings.AUTH_USER_MODEL`: a Django setting which is a string. `ForeignKey` can be used either by passing the class itself, or passing a string which is parsed to load and refer to the class. By passing `settings.AUTH_USER_MODEL`, we’ll be able to change the model class that’s used for authentication by updating the Django settings, and all models that refer to this setting will update automatically to use the right model. By default, the value is `auth.User`, which refers to the `User` model in the Django `auth` application.

To use the class in our `ForeignKey`, we need use the Django settings model. Verify that you have `from django.conf import settings` at the top of the file.

### Date Fields

The field `created_at` sets `auto_now_add` to `True` which means that when a `Post` is saved, its creation date and time will automatically be set. Similarly, `modified_at` is instantiated with `auto_now` set to `True`, which means it will be set to the current date and time whenever a `Post` is saved.

### Slugs and Slug Field

A *slug* is a short string designed to be used as an identifier, such as in a URL. Normally it is composed of lower case letters, numbers, and dashes. Slugs are used for search engine optimization (making pages rank higher in search engine results), as well as to make URLs more readable for humans.
Taking one of the posts from the official Django blog as an example: *djangoproject.com/weblog/2021/may/26/django-irc-channels-migration-liberachat/* . The slug from this URL is *django-irc-channels-migration-liberachat* . You can imagine that the Blog post probably has a numeric ID, but accessing it through a URL like *djangoproject.com/weblog/35* isn’t very friendly.

The slug is usually generated from the title of the page, with common words removed. In the Django example the page title is *Django IRC Channels migration to Libera.Chat* . You can see the slug is generated by converting to lowercase, switching spaces with dashes and removing non alpha-numeric characters.

The Django `SlugField` inherits from `CharField` but adds some validation to ensure the value looks like a slug (lowercase, alphanumeric and dashes only) and by default limits it to 50 characters.

Django provides the `[slugify]`([https://docs.djangoproject.com/en/3.2/ref/utils/#django.utils.text.slugify](https://docs.djangoproject.com/en/3.2/ref/utils/#django.utils.text.slugify)) function to convert an arbitrary string to a “slugified” version. We can also configure the Django admin to convert one field into a slug. For example, converting `title` to `slug`. We’ll see how to do this in the next section, *Django Admin Quickstart* .

### Content

For simplicity we’ll just be storing the actual blog content as HTML, so we don’t have to worry about doing any kind of conversion when displaying it, we’ll just render the content field verbatim. This is not the most secure approach, so it’s only advisable if you trust your authors not to add malicious HTML. If you’re building a site that will output user-supplied HTML, consider using something like [Bleach](https://bleach.readthedocs.io/en/latest/index.html) to remove unsafe HTML.

## Migrations

Before getting started with Django admin, we need to perform the usual steps when creating a new model. First, make the migrations with the `makemigrations` management command.

```bash
python3 manage.py makemigrations
```

If successful, you should see the following output:

```bash
Migrations for 'blog':
  blog/migrations/0001_initial.py
    - Create model Tag
    - Create model Post
```

Then apply the migrations to the database with the `migrate` management command.

```bash
python3 manage.py migrate
```

If successful, you should see the following output:

```bash
Operations to perform:
  Apply all migrations: admin, auth, blog, contenttypes, sessions
Running migrations:
  Applying blog.0001_initial... OK
```

## Reading Question

What is the purpose of the `Post` class?

- The `Post` class represents only the text of a blog post.
- ***The `Post` class represents a blog post, including information like tags, date, summary, etc.***
- The `Post` class represents the various tags that can be applied to a blog post.

> The `Post` class represents **all** of the information that makes up a blog post. That includes:
>
> * the author of the post
> * the date and time it was created
> * the date and time it was modified
> * the date and time it was published
> * the slug
> * the summary
> * the content of the blog post
> * any tags associated with the blog post
